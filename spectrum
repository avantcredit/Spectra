#!/usr/bin/env ruby

##
## Models
##

class Spectrum 
  
  attr_accessor :_prefix
  attr_accessor :colors, :formatters
  
  ##
  ## Main
  ##

  def self.generate 
    Spectrum.new.generate 
  end 

  def generate
    definition = IO.read('colors.rb')

    self.instance_eval definition    
    self.formats(:palette, :objc) unless self.formatters

    self.colors.each do |color|
      puts color.inspect
    end

    self.formatters.each do |formatter|
      puts formatter.format(self)
    end
  end

  ##
  ## DSL Methods
  ##
    
  def prefix(prefix)
    self._prefix = prefix 
  end
  
  def formats(*types) 
    types.each { |type| format(type) }
  end

  def format(type, &renamer)
    self.formatters ||= []
    self.formatters.concat(Formatter.from_type(type, renamer))
  end
   
  def color(name, attributes)
    self.colors ||= []
    self.colors << Color.new(name, attributes)
  end
  
end

class Color

  attr_accessor :name, :components
  
  def initialize(name, attributes)
    self.name = name
    self.components = self.components_from_attributes(attributes)
  end 

  def method_missing(name)
    self.valid_components.include?(name) ? self.components[name] : super
  end

  def valid_components
    [ :red, :green, :blue, :white, :alpha ]
  end

  ##
  ## Component Generation
  ##

  def components_from_attributes(attributes)
    components = map_attributes(attributes).pick(*self.valid_components)
    hex, white = attributes[:hex], components[:white]

    components.merge!(componentize_hex(hex)) if hex 
    components.merge!(componentize_white(white)) if white
    
    components.each { |key, value| components[key] = normalize(value) }
  end

  def componentize_hex(value)
    hex = value.is_a?(String) ? value.to_i : value
    return {
      red:   (hex & 0xFF0000) >> 16,
      green: (hex & 0x00FF00) >> 8,
      blue:  (hex & 0x0000FF)
    }    
  end

  def componentize_white(value)
    return { red: value, green: value, blue: value }
  end

  ##
  ## Helpers
  ##

  def normalize(number)
    number = number / 255.0 if number.is_a?(Fixnum)
    raise "component #{number} is not in a legible format" unless number.is_a?(Float)
    number.limit(0.0..1.0) 
  end
 
  def map_attributes(attributes)
    key_map = { r: :red, g: :green, b: :blue, w: :white, a: :alpha }
    return Hash[attributes.map { |key, value| [ key_map[key] || key, value ] }] 
  end

  ##
  ## Debugging
  ##

  def inspect
    return "#{self.name} :: #{self.components}" 
  end

end

##
## Formatters
##

class Formatter 
 
  attr_accessor :renamer
  attr_accessor :post_prefix_newlines, :intercolor_newlines, :pre_suffix_newlines
  
  def initialize(renamer)
    self.renamer = renamer
    self.post_prefix_newlines = self.intercolor_newlines = self.pre_suffix_newlines = 1
  end 

  ##
  ## Formatting
  ## 

  def format(spectrum)
    output = self.prefix(spectrum) + "\n" * self.post_prefix_newlines
    spectrum.colors.each_with_index { |color, index| output << format_indexed_color(color, index, spectrum) }
    output + "\n" * self.pre_suffix_newlines + self.suffix(spectrum)
  end

  def format_indexed_color(color, index, spectrum)
    name     = self.format_name(color, spectrum)
    newlines = index < spectrum.colors.length - 1 ? self.intercolor_newlines : 0
    self.format_color(color, name) + "\n" * newlines
  end

  def format_name(color, spectrum)
    self.renamer.call(color.name, spectrum._prefix)
  end

  def prefix(spectrum)
    ""
  end

  def suffix(spectrum)
    ""
  end

  ##
  ## Factory
  ##
   
  def self.from_type(type, renamer)
    case type.intern
      when :palette
        [ PaletteFormatter.new(renamer) ]
      when :objc    
        [ ObjcCategoryFormatter.new(renamer, true), ObjcCategoryFormatter.new(renamer, false) ]
      when :swift   
        [ SwiftExtensionFormatter.new(renamer) ]
      else raise "Specfied an invalid formatter type: #{type}"
    end
  end

end

class PaletteFormatter < Formatter

  def prefix(spectrum)
    "11"
  end

  def format_color(color, name)
    components = [ color.red, color.green, color.blue, color.alpha ]
    components.inject('0') { |memo, value| memo << ' ' << '%.3f' % (value || 0.0) } + " #{name}"
  end

  def format_value(value)
    '%.3f' % (value || 0.0)
  end

  def renamer
    @renamer ||= lambda { |name, prefix| name.camelize(true) }
  end

end

class ObjcCategoryFormatter < Formatter 
  
  attr_accessor :is_header

  def initialize(renamer, is_header) 
    super(renamer)
    self.is_header = is_header 
    self.post_prefix_newlines = self.pre_suffix_newlines = 2
    self.intercolor_newlines  = is_header ? 1 : 2
  end

  def prefix(spectrum)
    "@#{self.is_header ? 'interface' : 'implementation'} UIColor (#{spectrum._prefix.upcase}Color)"
  end

  def format_color(color, name)
    signature = "- (UIColor *)#{name}"
    if self.is_header
      "#{signature};"
    else
      "#{signature}\n{\n    return #{self.format_implementation(color)};\n}"
    end
  end

  def format_implementation(color)
    if color.white
      "[UIColor colorWithWhite:#{format_value(color.white)} alpha:#{format_value(color.alpha)}]"  
    else
      "[UIColor colorWithRed:#{format_value(color.red)} green:#{format_value(color.green)} blue:#{format_value(color.blue)} alpha:#{format_value(color.alpha)}]"
    end      
  end

  def format_value(value)
    '%.2f' % (value || 0.0) 
  end

  def suffix(attributes)
    "@end"
  end

  def renamer
    @renamer ||= lambda { |name, prefix| "#{prefix}_#{name.camelize(false)}Color" }
  end
 
end

class SwiftExtensionFormatter < Formatter

end

##
## Extensions
##

class Hash

  def pick(*keys)
    self.select { |key, value| keys.include?(key) }
  end

end

class Numeric
  
  def limit(range)
    self > range.max ? range.max : self < range.min ? range.min : self
  end 

end

class Symbol 
  
  def camelize(pascal)
    self.to_s.split('_').each_with_index do |component, index| 
      !pascal && index == 0 ? component : component.capitalize 
    end.join('') 
  end

end

Spectrum.generate

