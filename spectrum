#!/usr/bin/env ruby

class Colors
  
  attr_accessor :_prefix
  attr_accessor :colors, :formatters
  
  ##
  ## Main
  ##

  def self.generate 
    Colors.new.generate 
  end 

  def generate
    definition = IO.read('colors.rb')

    self.instance_eval definition    
    self.formats(:palette, :objc) unless self.formatters

    self.colors.each do |color|
      puts color.inspect
    end

    self.formatters.each do |formatter|
      puts formatter.format(self.colors, prefix: self._prefix)
    end
  end

  ##
  ## DSL Methods
  ##
    
  def prefix(prefix)
    self._prefix = prefix 
  end
  
  def formats(*types) 
    types.each { |type| format(type) }
  end

  def format(type, &renamer)
    self.formatters ||= []
    self.formatters.concat(Formatter.from_type(type, renamer))
  end
   
  def color(name, attributes)
    self.colors ||= []
    self.colors << Color.new(name, attributes)
  end
  
end

##
## Models
##

class Color

  attr_accessor :name, :components
  
  def initialize(name, attributes)
    self.name = name
    self.components = self.components_from_attributes(attributes)
  end 

  def method_missing(name)
    self.valid_components.include?(name) ? self.components[name] : super
  end

  def valid_components
    [ :red, :green, :blue, :white, :alpha ]
  end

  ##
  ## Component Generation
  ##

  def components_from_attributes(attributes)
    components = map_attributes(attributes).pick(*self.valid_components)
    hex, white = attributes[:hex], components[:white]

    components.merge!(componentize_hex(hex)) if hex 
    components.merge!(componentize_white(white)) if white
    
    components.each { |key, value| components[key] = normalize(value) }
  end

  def componentize_hex(value)
    hex = value.is_a?(String) ? value.to_i : value
    return {
      red:   (hex & 0xFF0000) >> 16,
      green: (hex & 0x00FF00) >> 8,
      blue:  (hex & 0x0000FF)
    }    
  end

  def componentize_white(value)
    return { red: value, green: value, blue: value }
  end

  ##
  ## Helpers
  ##

  def normalize(number)
    number = number / 255.0 if number.is_a?(Fixnum)
    raise "component #{number} is not in a legible format" unless number.is_a?(Float)
    number.limit(0.0..1.0) 
  end
 
  def map_attributes(attributes)
    key_map = { r: :red, g: :green, b: :blue, w: :white, a: :alpha }
    return Hash[attributes.map { |key, value| [ key_map[key] || key, value ] }] 
  end

  ##
  ## Debugging
  ##

  def inspect
    return "#{self.name} :: #{self.components}" 
  end

end

##
## Formatters
##

class Formatter 
 
  attr_accessor :renamer 
  
  def initialize(renamer)
    self.renamer = renamer
  end  

  ##
  ## Formatting
  ## 

  def format(colors, attributes)
    output = self.prefix(attributes)
    colors.each { |color| output << self.format_color(format_name(color, attributes), color) }
    output + self.suffix(attributes)
  end

  def format_name(color, attributes)
    self.renamer.call(color.name, attributes[:prefix])
  end

  def prefix(attributes)
    ""
  end

  def suffix(attributes)
    ""
  end

  ##
  ## Factory
  ##
   
  def self.from_type(type, renamer)
    case type.intern
      when :palette
        [ PaletteFormatter.new(renamer) ]
      when :objc    
        [ ObjcCategoryFormatter.new(renamer, true), ObjcCategoryFormatter.new(renamer, false) ]
      when :swift   
        [ SwiftExtensionFormatter.new(renamer) ]
      else raise "Specfied an invalid formatter type: #{type}"
    end
  end

end

class PaletteFormatter < Formatter

  def prefix(attributes)
    "11\n"
  end

  def format_color(name, color)
    components = [ color.red, color.green, color.blue, color.alpha ]
    components.inject('0') { |memo, value| memo << ' ' << '%.3f' % (value || 0.0) } + " #{name}\n"
  end

  def format_value(value)
    '%.3f' % (value || 0.0)
  end

  def renamer
    @renamer ||= lambda { |name, prefix| name.camelize(true) }
  end

end

class ObjcCategoryFormatter < Formatter 
  
  attr_accessor :is_header

  def initialize(renamer, is_header) 
    super(renamer)
    self.is_header = is_header 
  end

  def prefix(attributes)
    "@#{self.is_header ? 'interface' : 'implementation'} UIColor (#{attributes[:prefix].upcase}Color)\n"
  end

  def format_color(name, color)
    signature = "- (UIColor *)#{name}"
    if self.is_header
      "\n#{signature};"
    else
      "\n#{signature}\n{\n    return #{self.format_implementation(color)};\n}\n"
    end
  end

  def format_implementation(color)
    if color.white
      "[UIColor colorWithWhite:#{format_value(color.white)} alpha:#{format_value(color.alpha)}]"  
    else
      "[UIColor colorWithRed:#{format_value(color.red)} green:#{format_value(color.green)} blue:#{format_value(color.blue)} alpha:#{format_value(color.alpha)}]"
    end      
  end

  def format_value(value)
    '%.2f' % (value || 0.0) 
  end

  def suffix(attributes)
    "#{"\n" if self.is_header}\n@end"
  end

  def renamer
    @renamer ||= lambda { |name, prefix| "#{prefix}_#{name.camelize(false)}Color" }
  end
 
end

class SwiftExtensionFormatter < Formatter

end

##
## Extensions
##

class Hash

  def pick(*keys)
    self.select { |key, value| keys.include?(key) }
  end

end

class Numeric
  
  def limit(range)
    self > range.max ? range.max : self < range.min ? range.min : self
  end 

end

class Symbol 
  
  def camelize(pascal)
    self.to_s.split('_').each_with_index do |component, index| 
      !pascal && index == 0 ? component : component.capitalize 
    end.join('') 
  end

end

Colors.generate

